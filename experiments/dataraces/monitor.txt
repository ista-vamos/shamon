stream type ThreadEvent(threadid: int, tstate : int16_t, nonecount : uint16_t, nextts: uint64_t, nonets: uint64_t, optskipstart : uint64_t)
{
    read(timestamp: uint64_t, addr : uint64_t);
    write(timestamp: uint64_t, addr : uint64_t);
    atomicread(timestamp: uint64_t, addr : uint64_t, mode : int);
    atomicwrite(timestamp: uint64_t, addr : uint64_t, mode : int);
    lock(timestamp: uint64_t, addr : uint64_t);
    unlock(timestamp: uint64_t, addr : uint64_t);
    alloc(timestamp : uint64_t, addr : uint64_t, size : uint64_t);
    free(timestamp: uint64_t, addr : uint64_t);
    fork(timestamp: uint64_t, newthreadid: uint64_t) creates ThreadEvent;
    join(timestamp: uint64_t, threadid: uint64_t);
}
stream processor TEProcessor(threadid : int) : ThreadEvent(threadid, 0, 0, 0, 0, 0) -> ThreadEvent(threadid, 0, 0, 0, 0, 0) extends FORWARD
{
    on fork(ts, ntid) creates ThreadEvent process using TEProcessor(ntid) to autodrop(@BUFSIZE) include in Threads forward;
    my_hole
    {
        int n = COUNT(*);
        uint64_t firstts = MIN(read.timestamp, write.timestamp, atomicread.timestamp, atomicwrite.timestamp, lock.timestamp, unlock.timestamp, alloc.timestamp, free.timestamp, fork.timestamp, join.timestamp);
        uint64_t lastts = MAX(read.timestamp, write.timestamp, atomicread.timestamp, atomicwrite.timestamp, lock.timestamp, unlock.timestamp, alloc.timestamp, free.timestamp, fork.timestamp, join.timestamp);
    }
}

buffer group Threads : ThreadEvent order by nextts
event source Program : ThreadEvent process using TEProcessor(0) to autodrop(@BUFSIZE) include in Threads

stream type GlobalEvent
{
    read(tid: int, timestamp: uint64_t, addr : uint64_t);
    write(tid: int, timestamp: uint64_t, addr : uint64_t);
    atomicread(tid: int, timestamp: uint64_t, addr : uint64_t, mode : int);
    atomicwrite(tid: int, timestamp: uint64_t, addr : uint64_t, mode : int);
    lock(tid: int, timestamp: uint64_t, addr : uint64_t);
    unlock(tid: int, timestamp: uint64_t, addr : uint64_t);
    alloc(tid: int, timestamp : uint64_t, addr : uint64_t, size : uint64_t);
    free(tid: int, timestamp: uint64_t, addr : uint64_t);
    fork(tid: int, timestamp: uint64_t, newthreadid: int);
    join(tid: int, timestamp: uint64_t, threadid: int);
    skipstart(tid: int, timestamp : uint64_t);
    skipend(tid: int, timestamp : uint64_t);
    done_(tid: int);
}
globals
$$
    #include <limits.h>
    uint64_t nextts=1;
    uint64_t leastts=ULLONG_MAX;
    uint64_t skipcount=0;
    uint16_t nonebarrier=1;
    uint64_t nonecycles=0;
    int seenNone=0;

    #define min(a, b) __vamos_min(a, b)
    #define max(a, b) __vamos_max(a, b)
$$

arbiter : GlobalEvent
{
    choose first 5 T from Threads where $$ $T.nextts; <= nextts && ($T.nonecount; < nonebarrier || $T.nonets; < nextts) $$
    {
        on T : | read(ts,addr)
        $$
            if(ts==nextts)
            {
                $yield read(T.threadid, ts, addr);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | write(ts,addr)
        $$
            if(ts==nextts)
            {
                $yield write(T.threadid, ts, addr);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | atomicread(ts,addr,mode)
        $$
            if(ts==nextts)
            {
                $yield atomicread(T.threadid, ts, addr,mode);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | atomicwrite(ts,addr,mode)
        $$
            if(ts==nextts)
            {
                $yield atomicwrite(T.threadid, ts, addr,mode);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | lock(ts,addr)
        $$
            if(ts==nextts)
            {
                $yield lock(T.threadid, ts, addr);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | unlock(ts,addr)
        $$
            if(ts==nextts)
            {
                $yield unlock(T.threadid, ts, addr);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | alloc(ts,addr,size)
        $$
            if(ts==nextts)
            {
                $yield alloc(T.threadid, ts, addr, size);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | free(ts,addr)
        $$
            if(ts==nextts)
            {
                $yield free(T.threadid, ts, addr);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | fork(ts,tid)
        $$
            if(ts==nextts)
            {
                $yield fork(T.threadid, ts, tid);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | join(ts,tid)
        $$
            if(ts==nextts)
            {
                $yield join(T.threadid, ts, tid);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else if(ts>nextts)
            {
                $T.nextts;=ts;
                leastts=min(leastts, ts);
            }
            else
            {
                $drop 1 from T;
            }
        $$
        on T : | my_hole(n, mints, maxts)
        $$
            printf("\033[36m[a] my_hole(n=%lu, mints=%lu, maxts=%lu)\033[0m\n", n, mints, maxts);
            if(mints<=nextts)
            {
                skipcount+=n;
                $yield skipstart(T.threadid, nextts);
                $T.nextts;=maxts;
                leastts=maxts;
                if(maxts<=nextts)
                {
                    $yield skipend(T.threadid, nextts);
                    $drop 1 from T;
                    leastts=ULLONG_MAX;
                }
                if(mints==nextts)
                {
                    nextts++;
                }
            }
            else if(maxts==nextts)
            {
                $yield skipend(T.threadid, maxts);
                $drop 1 from T;
                nextts++;
                leastts=ULLONG_MAX;
            }
            else
            {
                $T.nextts;=mints;
                leastts=min(leastts, mints);
            }
        $$
        on T : done
        $$
            $yield done_(T.threadid);
            $remove T from Threads;
        $$
        on T : nothing
        $$
            if($T.nonets;<nextts)
            {
                $T.nonecount;=0;
                $T.nonets;=nextts;
            }
            $T.nonecount;+=1;
            seenNone=1;
        $$
    }

    always
    $$
        if((!seenNone) || (nonecycles>1000 && skipcount >= leastts - nextts))
        {
            if(leastts!=ULLONG_MAX)
            {
                if(!seenNone)
                {
                    skipcount-=(leastts-nextts);
                }
                nextts=leastts;
            }
            else
            {
                if(!seenNone)
                {
                    skipcount-=1;
                }
                nextts++;
            }
            nonebarrier=1;
            nonecycles=0;
        }
        else
        {                
            nonebarrier++;
            nonecycles++;
        }
        seenNone=0;
    $$
}

monitor {
    on read(tid, timestamp, addr) where $$ true $$
    $$
        printf("read(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on write(tid, timestamp, addr) where $$ true $$
    $$
        printf("write(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on atomicread(tid, timestamp, addr , mode) where $$ true $$
    $$
        printf("atomicread(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on atomicwrite(tid, timestamp, addr , mode) where $$ true $$
    $$
        printf("atomicwrite(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on lock(tid, timestamp, addr) where $$ true $$
    $$
        printf("lock(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on unlock(tid, timestamp, addr) where $$ true $$
    $$
        printf("unlock(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
    $$

    on alloc(tid, timestamp , addr, size) where $$ true $$ $$ printf("ALLOC\n"); $$
    on free(tid, timestamp, addr ) where $$ true $$        $$ printf("FREE\n"); $$
    on fork(tid, timestamp, newthreadid) where $$ true $$
    $$
        printf("fork(tid=%lu, ts=%lu, newtid=%lu\n", tid, timestamp, newthreadid);
    $$
    on join(tid, timestamp, threadid) where $$ true $$
    $$
        printf("join(tid=%lu, ts=%lu, jointid=%lu\n", tid, timestamp, threadid);
    $$
    on skipstart(tid, timestamp ) where $$ true $$
    $$
        printf("skipstart(tid=%lu, ts=%lu)\n", tid, timestamp);
    $$
    on skipend(tid, timestamp ) where $$ true $$
    $$
        printf("skipend(tid=%lu, ts=%lu)\n", tid, timestamp);
    $$
    on done_(tid) where $$ true $$                         $$ printf("DONE\n"); $$

}
