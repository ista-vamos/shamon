stream type BankOutputEvent
{
    balance(timestamp: uint64_t, account : int);
    depositTo(timestamp: uint64_t, account : int);
    withdraw(timestamp: uint64_t, account: int);
    transfer(timestamp: uint64_t, fromAccount: int, toAccount: int);
    depositSuccess(timestamp: uint64_t);
    depositFail(timestamp: uint64_t);
    withdrawSuccess(timestamp: uint64_t);
    withdrawFail(timestamp: uint64_t);
    transferSuccess(timestamp: uint64_t);
    selectedAccount(timestamp: uint64_t, account: int);
    logout(timestamp: uint64_t);
    numOut(timestamp: uint64_t, num: int);
}

stream type BankInputEvent
{
    numIn(timestamp: uint64_t, num : int);
    otherIn(timestamp: uint64_t);
}

stream type BankEvent
{
    SawBalance(account : int, balance : int);
    SawDeposit(account : int, amount : int);
    SawWithdraw(account : int, amount : int);
    SawWithdrawFail(account : int, amount : int);
    SawTransfer(from_ : int, to_ : int, amount : int);
    SawTransferFail(from_ : int, to_ : int, amount : int);
    Clear();
}

event source In : BankInputEvent to autodrop(1024)
event source Out : BankOutputEvent to autodrop(1024)

globals
$$
    #include <stdio.h>
    #include "./compiler/cfiles/intmap.h"

    int in_processed=0;
    int out_processed=0;
    int in_holes=0;
    int out_holes=0;

    uint64_t timestamp = 0;

    FILE *tessla_in;
$$

startup
$$
    tessla_in = fopen("/tmp/tessla.in", "w");
    if (tessla_in == NULL) {
	fprintf(stderr, "Failed openning TeSSLa fifo\n");
	abort();
    }
$$

cleanup
$$
printf("\nin_processed: %i, out_processed: %i\n", in_processed, out_processed);
printf("in_holes: %i, out_holes: %i\n", in_holes, out_holes);
fflush(stdout);
fclose(tessla_in);
$$

arbiter : BankEvent
{
    rule set aligning {
    on Out : | selectedAccount(tout, acc),
       In  : | numIn(tin, n)
       where $$ true $$
    $$
        if (tin < tout){
        $drop 1 from In;
        ++in_processed;
        } else {
        ++out_processed;
        $drop 1 from Out;
        $switch to working;
        }
    $$

    on Out : | selectedAccount(tout, acc),
       In  : | otherIn(tin)
       where $$ true $$
    $$
        if (tin < tout){
        $drop 1 from In;
        ++in_processed;
        } else {
        ++out_processed;
        $drop 1 from Out;
        $switch to working;
        }
    $$

    on Out : | balance(t, a) where $$ true $$
    $$
        /* this can happen only after a hole */
        assert(out_holes > 0 && "Balance when aligning");
    $$

    on Out : | transfer(t, frm, t_) where $$ true $$
    $$
        /* this can happen only after a hole */
        assert(out_holes > 0 && "Transfer when aligning");
    $$

    on Out : | withdraw(t, frm) where $$ true $$
    $$
        /* this can happen only after a hole */
        assert(out_holes > 0 && "Withdraw when aligning");
    $$

    on Out : 1, In : 1 where $$ true $$
    $$
        ++out_processed;
        $drop 1 from Out;
    $$

    on Out : done, In : 1 where $$ true $$
    $$
        ++in_processed;
        $drop 1 from In;
    $$
    }

    rule set working
    {
        on In : hole(n) | where $$ true $$
        $$
            $yield Clear();
       	    ++in_holes;
       	    ++in_processed;
            $switch to aligning;
        $$

        on Out : hole(n) | where $$ true $$
        $$
            $yield Clear();
            ++out_holes;
            ++out_processed;
            $switch to aligning;
        $$

        on Out : balance(t2, acc) numOut(t3, amnt) |,
           In  : numIn(t1, action) | where $$ true $$
        $$
        assert(action == 3);
            $yield SawBalance(acc, amnt);
            out_processed += 2;
            ++in_processed;
            $switch to aligning;
        $$

        on Out : transfer(t2, from_, to_) transferSuccess(t4) |,
           In  : numIn(t0, action) numIn(t1, acc) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(action == 4);
            $yield SawTransfer(from_, to_, amnt);
            out_processed += 2;
            in_processed += 3;
            $switch to aligning;
        $$

        on Out : transfer(t2, from_, to_) selectedAccount(t4, acc) |,
           In  : numIn(t0, action) numIn(t1, acc) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(action == 4);
            $yield SawTransferFail(from_, to_, amnt);
            out_processed += 2;
            in_processed += 3;
        $$

        on Out : depositTo(t2, acc) depositSuccess(t4) |,
           In  : numIn(t1, action) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(action == 1);
            $yield SawDeposit(acc, amnt);
            out_processed += 2;
            in_processed += 2;
            $switch to aligning;
        $$

        on Out : depositTo(t2, acc) depositFail(t4) |,
           In  : numIn(t1, action) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(action == 1);
            out_processed += 2;
            in_processed += 2;
            $switch to aligning;
        $$

        on Out : withdraw(t2, acc) withdrawSuccess(t4) |,
           In  : numIn(t1, act) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(act == 2);
            $yield SawWithdraw(acc, amnt);
            out_processed += 2;
            in_processed += 2;
            $switch to aligning;
        $$

        on Out : withdraw(t2, acc) withdrawFail(t4) |,
           In  : numIn(t1, act) numIn(t3, amnt) |
           where $$ true $$
        $$
            assert(act == 2);
            $yield SawWithdrawFail(acc, amnt);
            out_processed += 2;
            in_processed += 2;
            $switch to aligning;
        $$

    on Out : numOut(t, n) |, In: 1 where $$ true $$
    $$
        /* just align again -- if numOut does not follow any
           interesting event, it is garbage (likely
           from selecting a different account )*/
        $switch to aligning;
    $$

    on Out : selectedAccount(t, acc) | where $$ true $$
    $$
        assert(0 && "Should not happen");
    $$

    on Out : logout(t) | where $$ true $$
    $$
        ++out_processed;
        $switch to aligning;
    $$
    }
}

monitor (128) {

    on SawBalance(account, balance) where $$ true $$
    $$
        fprintf(tessla_in, "%lu: ubound = (%d, %d)\n", ++timestamp, account, balance);
        fprintf(tessla_in, "%lu: lbound = (%d, %d)\n", timestamp, account, balance);
    $$

    on SawDeposit(account, amount) where $$ true $$
    $$
        fprintf(tessla_in, "%lu: change = (%d, %d)\n", ++timestamp, account, amount);
    $$

    on SawWithdraw(account, amount) where $$ true $$
    $$
        fprintf(tessla_in, "%lu: check_atleast = (%d, %d)\n", ++timestamp, account, amount);
        fprintf(tessla_in, "%lu: change = (%d, %d)\n", ++timestamp, account, -amount);
    $$

    on SawWithdrawFail(account, amount) where $$ true $$
    $$
        fprintf(tessla_in, "%lu: check_less = (%d, %d)\n", ++timestamp, account, amount);
    $$

    on SawTransfer(from_, to_, amount) where $$ true $$
    $$
        fprintf(tessla_in, "%lu: check_atleast = (%d, %d)\n", ++timestamp, from_, amount);
        fprintf(tessla_in, "%lu: change = (%d, %d)\n", ++timestamp, from_, -amount);
        fprintf(tessla_in, "%lu: change = (%d, %d)\n", ++timestamp, to_, amount);
    $$

    on SawTransferFail(from_, to_, amount) where $$ true $$
    $$
	if (amount > 0) {
            fprintf(tessla_in, "%lu: check_less = (%d, %d)\n", ++timestamp, from_, amount);
            fprintf(tessla_in, "%lu: ubound = (%d, %d)\n", ++timestamp, from_, amount - 1);
	}
    $$

    on Clear() where $$ true $$
    $$
        fprintf(tessla_in, "%lu: reset\n", ++timestamp);
    $$
}
