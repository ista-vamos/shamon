stream type Primes
{
    Prime(n : int, p : int);  
}

stream type PrimeEvents
{
    LPrime(n : int, p : int);
    RPrime(n : int, p : int);
    LSkip(n : int);
    RSkip(n : int);
}

event source Left : Primes -> autodrop(8) Primes
{
    on Prime(n, p) forward Prime(n,p);
}

event source Right : Primes -> autodrop(8) Primes
{
    on Prime(n, p) forward Prime(n,p);
}

globals
{
    #include "map.h"
    int lpos=1;
    int rpos=1;
    int leftAhead=1;
    int count=0;
    intmap pbuf;
}

arbiter : PrimeEvents
{
    rule set EQ
    {
        on Left : Prime(n,p) | [] where $$ true $$
        {
            if(n==lpos)
            {
                lpos = lpos + 1;
                yield LPrime(n,p);
                switch to LeftAhead;
            }
            else if(n<lpos)
            {
                printf("Error: expected %ith left prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith left prime, but got %ith - fastforwarding...\n", lpos, n);
                lpos = n + 1;
                switch to LeftAhead;
            }
        }
        on Right : Prime(n,p) | [] where $$ true $$
        {
            if(n==rpos)
            {
                rpos = rpos + 1;
                yield RPrime(n,p);
                switch to RightAhead;
            }
            else if(n<rpos)
            {
                printf("Error: expected %ith right prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith right prime, but got %ith - fastforwarding...\n", lpos, n);
                rpos = n + 1;
                switch to RightAhead;
            }
        }
        on Left : hole(n) | [] where $$ true $$
        {
            lpos = lpos + n;
            switch to LeftAhead;
        }
        on Right : hole(n) | [] where $$ true $$
        {
            rpos = rpos + n;
            switch to RightAhead;
        }
    }
    
    rule set LeftAhead
    {
        on Right : Prime(n,p) | [] where $$ true $$
        {
            if(n==rpos)
            {
                rpos = rpos + 1;
                yield RPrime(n,p);
                if(rpos==lpos)
                {
                    switch to EQ;
                }
            }
            else if(n<rpos)
            {
                printf("Error: expected %ith right prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith right prime, but got %ith - fastforwarding...\n", lpos, n);
                rpos = n + 1;
                if(rpos==lpos)
                {
                    switch to EQ;
                }
                else if(rpos>lpos)
                {
                    switch to RightAhead;
                }
            }
        }
        on Left : Prime(n,p) | [] where $$ true $$
        {
            if(n==lpos)
            {
                lpos = lpos + 1;
                yield LPrime(n,p);
            }
            else if(n<lpos)
            {
                printf("Error: expected %ith left prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith left prime, but got %ith - fastforwarding...\n", lpos, n);
                lpos = n + 1;
            }
        }
        on Right : hole(n) | [] where $$ true $$
        {
            rpos = rpos + n;
            yield RSkip(rpos-1);
            if(rpos==lpos)
            {
                switch to EQ;
            }
            else if(rpos>lpos)
            {
                switch to RightAhead;
            }
        }
        on Left : hole(n) | [] where $$ true $$
        {
            lpos = lpos + n;
        }
    }
    
    rule set RightAhead
    {
        on Left : Prime(n,p) | [] where $$ true $$
        {
            if(n==lpos)
            {
                lpos = lpos + 1;
                $yield LPrime(n,p);
            }
            else if(n<lpos)
            {
                printf("Error: expected %ith left prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith left prime, but got %ith - fastforwarding...\n", lpos, n);
                lpos = n + 1;
            }
        }
        on Right : Prime(n,p) | [] where $$ true $$
        {
            if(n==rpos)
            {
                rpos = rpos + 1;
                yield RPrime(n,p);
                if(rpos==lpos)
                {
                  switch to EQ;
                }
            }
            else if(n<rpos)
            {
                printf("Error: expected %ith right prime, but got %ith\n", lpos, n);
            }
            else
            {
                printf("Error: expected %ith right prime, but got %ith - fastforwarding...\n", lpos, n);
                rpos = n + 1;
                if(rpos==lpos)
                {
                    switch to EQ;
                }
                else if(rpos>lpos)
                {
                    switch to RightAhead;
                }
            }
        }
        on Left : hole(n) | [] where $$ true $$
        {
            lpos = lpos + n;
            yield LSkip(lpos-1);
            if(lpos==rpos)
            {
                switch to EQ;
            }
            else if(lpos>rpos)
            {
                switch to LeftAhead;
            }
        }
        on Right : hole(n) | [] where $$ true $$
        {
            rpos = rpos + n;
        }
    }
}

monitor
{
    on LPrime(n,p) where true
    {
        if(count==0||leftAhead)
        {
            leftAhead=1;
            if(count<10)
            {
                mapInsert(&pbuf, n, p);
                count++;
            }
        }
        else
        {
            int rprime=0;
            if(mapGet(&pbuf, n, &rprime))
            {
                if(rprime!=p)
                {
                    printf("ERROR at index %i - left: %i / right: %i\n", n, p, rprime);
                }
                count -= mapRemoveLeq(&pbuf, n);
            }
        }
    }
    on RPrime(n,p) where $$ true $$
    {
        if(count==0||!leftAhead)
        {
            leftAhead=0;
            if(count<10)
            {
                mapInsert(&pbuf, n, p);
                count++;
            }
        }
        else
        {
            int lprime=0;
            if(mapGet(&pbuf, n, &lprime))
            {
                if(lprime!=p)
                {
                    printf("ERROR at index %i - left: %i / right: %i\n", n, lprime, p);
                }
                count -= mapRemoveLeq(&pbuf, n);
            }
        }
    }
    on LSkip(n) where $$ true $$
    {
        if(leftAhead==0)
        {
            count -= mapRemoveLeq(&pbuf, n);
        }
    }
    on RSkip(n) where $$ true $$
    {
        if(leftAhead)
        {
            count -= mapRemoveLeq(&pbuf, n);
        }
    }
}

startup
{
    init_intmap(&pbuf);
}

